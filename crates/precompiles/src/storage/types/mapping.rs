//! Type-safe wrapper for EVM storage mappings (hash-based key-value storage).

use alloy::primitives::{Address, U256, keccak256};
use std::{marker::PhantomData, rc::Rc};

use crate::storage::{Layout, LayoutCtx, Slot, Storable, StorableType, StorageKey};

/// Type-safe access wrapper for EVM storage mappings (hash-based key-value storage).
///
/// This struct does not store data itself. Instead, it provides a zero-cost abstraction
/// for accessing mapping storage slots using Solidity's hash-based layout. It wraps a
/// base slot number and provides methods to compute the actual storage slots for keys.
///
/// # Type Parameters
///
/// - `K`: Key type (must implement `StorageKey`)
/// - `V`: Value type (must implement `Storable<N>`)
///
/// # Storage Layout
///
/// Mappings use Solidity's storage layout:
/// - Base slot: stored in `base_slot` field (never accessed directly)
/// - Actual slot for key `k`: `keccak256(k || base_slot)`
///
/// # Usage Pattern
///
/// The typical usage follows a composable pattern:
/// 1. Create a `Mapping<K, V>` with a base slot (usually from generated constants)
/// 2. Call `.at(key)` to compute and obtain a `Slot<V>` for that key
/// 3. Use `.read()`, `.write()`, or `.delete()` on the resulting slot
///
/// # Accessing Mapping Fields Within Structs
///
/// When a mapping is a field within a struct stored in another mapping, use the static
/// `at_offset` method to compute the slot without creating a `Mapping` instance:
///
/// # Relationship with `Slot<V>`
///
/// `Mapping<K, V>` is essentially a slot computation helper. The `.at(key)` method
/// performs the keccak256 hash to compute the actual storage slot and returns a
/// `Slot<V>` that can be used for read/write operations.
#[derive(Debug, Clone)]
pub struct Mapping<K, V> {
    base_slot: U256,
    address: Rc<Address>,
    _phantom: PhantomData<(K, V)>,
}

impl<K, V> Mapping<K, V> {
    /// Creates a new `Mapping` with the given base slot number and address.
    ///
    /// This is typically called with slot constants generated by the `#[contract]` macro.
    #[inline]
    pub fn new(base_slot: U256, address: Rc<Address>) -> Self {
        Self {
            base_slot,
            address,
            _phantom: PhantomData,
        }
    }

    /// Returns the U256 base storage slot number for this mapping.
    #[inline]
    pub const fn slot(&self) -> U256 {
        self.base_slot
    }

    /// Returns a `Slot<V>` for the given key.
    ///
    /// This enables the composable pattern: `mapping.at(key).read()`
    /// where the mapping slot computation happens once, and the resulting slot
    /// can be used for multiple operations.
    pub fn at<const N: usize>(&self, key: K) -> Slot<V>
    where
        K: StorageKey,
        V: Storable<N>,
    {
        Slot::new(
            mapping_slot(key.as_storage_bytes(), self.base_slot),
            Rc::clone(&self.address),
        )
    }

    /// Returns a `Slot<V>` for a mapping field within a struct at a given base slot.
    ///
    /// This method enables accessing mapping fields within structs when you have
    /// the struct's base slot at runtime and know the field's offset.
    #[inline]
    pub fn at_offset<const N: usize>(
        struct_base_slot: U256,
        field_offset_slots: usize,
        address: Rc<Address>,
        key: K,
    ) -> Slot<V>
    where
        K: StorageKey,
        V: Storable<N>,
    {
        let field_slot = struct_base_slot + U256::from(field_offset_slots);
        Slot::new(mapping_slot(key.as_storage_bytes(), field_slot), address)
    }
}

/// Type-safe access wrapper for nested EVM storage mappings (two-level hash-based storage).
///
/// Like `Mapping<K, V>`, this struct does not store data. It provides a zero-cost abstraction
/// for accessing nested mapping storage using Solidity's double-hash layout. It wraps a base
/// slot and provides methods to navigate through two levels of key lookups.
///
/// # Type Parameters
///
/// - `K1`: First-level key type (must implement `StorageKey`)
/// - `K2`: Second-level key type (must implement `StorageKey`)
/// - `V`: Value type (must implement `Storable<N>`)
///
/// # Storage Layout
///
/// Nested mappings use a two-step hashing process:
/// - Base slot: stored in the inner mapping's `base_slot`
/// - Intermediate slot for `k1`: `keccak256(k1 || base_slot)`
/// - Final slot for `k1, k2`: `keccak256(k2 || intermediate_slot)`
///
/// # Usage Pattern
///
/// The typical usage follows a two-step composable pattern:
/// 1. Create a `NestedMapping<K1, K2, V>` with a base slot
/// 2. Call `.at(key1)` to get an intermediate `Mapping<K2, V>`
/// 3. Call `.at(key2)` on the intermediate mapping to get a `Slot<V>`
/// 4. Use `.read()`, `.write()`, or `.delete()` on the resulting slot
///
/// # Accessing Nested Mapping Fields Within Structs
///
/// When a nested mapping is a field within a struct, you can manually compute the field's
/// slot by adding the offset to the struct's base slot, then create a new `NestedMapping`:
///
/// # Relationship with `Mapping<K, V>` and `Slot<V>`
///
/// `NestedMapping<K1, K2, V>` internally wraps `Mapping<K1, Mapping<K2, V>>`. The first
/// `.at(k1)` call performs the first hash to compute an intermediate slot and returns a
/// `Mapping<K2, V>`. The second `.at(k2)` call on that mapping performs the second hash
/// and returns a `Slot<V>` for read/write operations.
#[derive(Debug, Clone)]
pub struct NestedMapping<K1, K2, V> {
    _inner: Mapping<K1, Mapping<K2, V>>,
}

impl<K1, K2, V> NestedMapping<K1, K2, V> {
    /// Creates a new `NestedMapping` with the given base slot number and address.
    ///
    /// This is typically called with slot constants generated by the `#[contract]` macro.
    #[inline]
    pub fn new(base_slot: U256, address: Rc<Address>) -> Self {
        Self {
            _inner: Mapping::new(base_slot, address),
        }
    }

    /// Returns the U256 base storage slot number for this nested mapping.
    #[inline]
    pub const fn slot(&self) -> U256 {
        self._inner.slot()
    }

    /// Returns a `Mapping<K2, V>` for the given first-level key.
    #[inline]
    pub fn at(&self, key1: K1) -> Mapping<K2, V>
    where
        K1: StorageKey,
    {
        let intermediate_slot = mapping_slot(key1.as_storage_bytes(), self._inner.base_slot);
        Mapping::new(intermediate_slot, Rc::clone(&self._inner.address))
    }
}

impl<K, V> Default for Mapping<K, V> {
    fn default() -> Self {
        Self::new(U256::ZERO, Rc::new(Address::ZERO))
    }
}

impl<K1, K2, V> Default for NestedMapping<K1, K2, V> {
    fn default() -> Self {
        Self::new(U256::ZERO, Rc::new(Address::ZERO))
    }
}

// Mappings occupy a full 32-byte slot in the layout (used as a base for hashing),
// even though they don't store data in that slot directly.
//
// **NOTE:** Necessary to allow it to participate in struct layout calculations.
impl<K, V> StorableType for Mapping<K, V> {
    const LAYOUT: Layout = Layout::Slots(1);
    type Handler = Self;

    fn handle(slot: U256, _ctx: LayoutCtx, address: Rc<Address>) -> Self::Handler {
        Self::new(slot, address)
    }
}

// Nested mappings occupy a full 32-byte slot in the layout (used as a base for hashing),
// even though they don't store data in that slot directly.
//
// **NOTE:** Necessary to allow it to participate in struct layout calculations.
impl<K1, K2, V> StorableType for NestedMapping<K1, K2, V> {
    const LAYOUT: Layout = Layout::Slots(1);
    type Handler = Self;

    fn handle(slot: U256, _ctx: LayoutCtx, address: Rc<Address>) -> Self::Handler {
        Self::new(slot, address)
    }
}

// -- HELPER FUNCTIONS ---------------------------------------------------------

fn left_pad_to_32(data: &[u8]) -> [u8; 32] {
    let mut buf = [0u8; 32];
    buf[32 - data.len()..].copy_from_slice(data);
    buf
}

/// Compute storage slot for a mapping
#[inline]
pub fn mapping_slot<T: AsRef<[u8]>>(key: T, mapping_slot: U256) -> U256 {
    let mut buf = [0u8; 64];
    buf[..32].copy_from_slice(&left_pad_to_32(key.as_ref()));
    buf[32..].copy_from_slice(&mapping_slot.to_be_bytes::<32>());
    U256::from_be_bytes(keccak256(buf).0)
}

#[cfg(test)]
mod tests {
    use super::*;
    use alloy::primitives::{Address, B256};
    use std::rc::Rc;

    #[test]
    fn test_left_padding_correctness() {
        let addr = Address::random();
        let bytes: &[u8] = addr.as_ref();
        let padded = left_pad_to_32(bytes);

        // First 12 bytes should be zeros (left padding)
        assert_eq!(&padded[..12], &[0u8; 12]);
        // Last 20 bytes should be the address
        assert_eq!(&padded[12..], bytes);
    }

    #[test]
    fn test_mapping_slot_encoding() {
        let key = Address::random();
        let base_slot = U256::random();

        // Manual computation to validate
        let mut buf = [0u8; 64];
        // Left-pad the address to 32 bytes
        buf[12..32].copy_from_slice(key.as_ref());
        // Slot in big-endian
        buf[32..].copy_from_slice(&base_slot.to_be_bytes::<32>());

        let expected = U256::from_be_bytes(keccak256(buf).0);
        let computed = mapping_slot(key, base_slot);

        assert_eq!(computed, expected, "mapping_slot encoding mismatch");
    }

    #[test]
    fn test_mapping_size() {
        // Mapping contains: U256 base_slot (32 bytes) + Rc<Address> (8 bytes) + PhantomData (0 bytes) = 40 bytes
        assert_eq!(std::mem::size_of::<Mapping<Address, U256>>(), 40);
        assert_eq!(std::mem::size_of::<Mapping<U256, Address>>(), 40);
        // Nested mapping wraps an inner Mapping, so same size
        assert_eq!(
            std::mem::size_of::<NestedMapping<Address, Address, U256>>(),
            40
        );
    }

    #[test]
    fn test_mapping_basic_properties() {
        let address = Rc::new(Address::random());
        let base_slot = U256::random();
        let mapping = Mapping::<Address, U256>::new(base_slot, Rc::clone(&address));

        // Property 1: Determinism - same key always produces same slot
        let key = Address::random();
        let slot1 = mapping.at::<1>(key);
        let slot2 = mapping.at::<1>(key);
        assert_eq!(
            slot1.slot(),
            slot2.slot(),
            "same key should produce same slot"
        );

        // Property 2: Different keys produce different slots
        let key1 = Address::random();
        let key2 = Address::random();
        let slot_a = mapping.at::<1>(key1);
        let slot_b = mapping.at::<1>(key2);
        assert_ne!(
            slot_a.slot(),
            slot_b.slot(),
            "different keys should produce different slots"
        );

        // Property 3: Derived slot matches manual computation
        let test_key = Address::random();
        let derived_slot = mapping.at::<1>(test_key);
        let expected_slot = mapping_slot(test_key, base_slot);
        assert_eq!(
            derived_slot.slot(),
            expected_slot,
            ".at() should derive correct slot"
        );
    }

    #[test]
    fn test_nested_mapping_basic_properties() {
        let address = Rc::new(Address::random());
        let base_slot = U256::random();
        let nested = NestedMapping::<Address, B256, U256>::new(base_slot, Rc::clone(&address));

        let key1 = Address::random();
        let key2 = B256::random();

        // Property 1: Chaining - first .at() returns intermediate Mapping with correct slot
        let intermediate = nested.at(key1);
        let expected_intermediate_slot = mapping_slot(key1, base_slot);
        assert_eq!(
            intermediate.slot(),
            expected_intermediate_slot,
            "intermediate mapping should have correct slot"
        );

        // Property 2: Double-hash - second .at() returns final Slot with correct double-derived slot
        let final_slot = intermediate.at::<1>(key2);
        let expected_final_slot = mapping_slot(key2, expected_intermediate_slot);
        assert_eq!(
            final_slot.slot(),
            expected_final_slot,
            "final slot should use double-hash"
        );

        // Property 3: Determinism - same keys always produce same slot
        let slot_a = nested.at(key1).at::<1>(key2);
        let slot_b = nested.at(key1).at::<1>(key2);
        assert_eq!(
            slot_a.slot(),
            slot_b.slot(),
            "same keys should produce same slot"
        );

        // Property 4: Different first-level keys produce different final slots
        let different_key1 = Address::random();
        let different_slot = nested.at(different_key1).at::<1>(key2);
        assert_ne!(
            final_slot.slot(),
            different_slot.slot(),
            "different first-level keys should produce different slots"
        );

        // Property 5: Different second-level keys produce different final slots
        let different_key2 = B256::random();
        let another_slot = nested.at(key1).at::<1>(different_key2);
        assert_ne!(
            final_slot.slot(),
            another_slot.slot(),
            "different second-level keys should produce different slots"
        );
    }

    #[test]
    fn test_mapping_slot_boundaries() {
        let address = Rc::new(Address::random());

        // Test .slot() getter with ZERO boundary
        let zero_mapping = Mapping::<Address, U256>::new(U256::ZERO, Rc::clone(&address));
        assert_eq!(zero_mapping.slot(), U256::ZERO);
        let user = Address::random();
        let slot = zero_mapping.at::<1>(user);
        assert_eq!(slot.slot(), mapping_slot(user, U256::ZERO));

        // Test .slot() getter with MAX boundary
        let max_mapping = Mapping::<Address, U256>::new(U256::MAX, Rc::clone(&address));
        assert_eq!(max_mapping.slot(), U256::MAX);
        let user2 = Address::random();
        let slot2 = max_mapping.at::<1>(user2);
        assert_eq!(slot2.slot(), mapping_slot(user2, U256::MAX));

        // Test .slot() getter with arbitrary values
        let random_slot = U256::random();
        let arbitrary_mapping = Mapping::<Address, U256>::new(random_slot, Rc::clone(&address));
        assert_eq!(arbitrary_mapping.slot(), random_slot);
    }

    #[test]
    fn test_mapping_at_offset() {
        // Simulate: mapping(bytes32 => Orderbook) books
        // where Orderbook has a mapping field `bids` at field offset 1
        let pair_key = B256::random();
        let books_base_slot = U256::random();
        let orderbook_base_slot = mapping_slot(pair_key, books_base_slot);

        // Test that Mapping::at_offset() computes the correct slot
        let tick: i16 = 123;
        let address = Rc::new(Address::random());

        let slot = Mapping::<i16, U256>::at_offset(
            orderbook_base_slot,
            1, // bids field is at offset 1 in Orderbook
            Rc::clone(&address),
            tick,
        );

        // Verify the slot was computed correctly:
        // 1. Field slot = orderbook_base_slot + 1
        // 2. Mapping slot = keccak256(tick || field_slot)
        let field_slot = orderbook_base_slot + U256::from(1);
        let expected_slot = mapping_slot(tick.to_be_bytes(), field_slot);
        assert_eq!(slot.slot(), expected_slot);
    }

    #[test]
    fn test_nested_mapping_at_offset() {
        // Simulate a struct with nested mapping at field offset 3
        let struct_key = B256::random();
        let mapping_base_slot = U256::random();
        let struct_base_slot = mapping_slot(struct_key, mapping_base_slot);

        let owner = Address::random();
        let spender = Address::random();

        // Test that NestedMapping computes slots correctly when created at an offset
        let field_slot = struct_base_slot + U256::from(3); // nested mapping at field offset 3
        let nested_mapping =
            NestedMapping::<Address, Address, U256>::new(field_slot, Rc::new(Address::random()));

        // Verify double-hash computation is correct
        let final_slot = nested_mapping.at(owner).at(spender);

        // Expected: keccak256(spender || keccak256(owner || field_slot))
        let intermediate_slot = mapping_slot(owner, field_slot);
        let expected_slot = mapping_slot(spender, intermediate_slot);
        assert_eq!(final_slot.slot(), expected_slot);
    }

    #[test]
    fn test_multiple_fields_at_different_offsets() {
        // Simulate Orderbook with multiple mapping fields at different offsets
        let pair_key = B256::random();
        let books_base_slot = U256::random();
        let orderbook_base = mapping_slot(pair_key, books_base_slot);
        let address = Rc::new(Address::random());

        // bids at offset 1
        let tick1: i16 = 111;
        let bids_slot =
            Mapping::<i16, U256>::at_offset(orderbook_base, 1, Rc::clone(&address), tick1);

        // asks at offset 2
        let tick2: i16 = 222;
        let asks_slot =
            Mapping::<i16, U256>::at_offset(orderbook_base, 2, Rc::clone(&address), tick2);

        // bidBitmap at offset 3
        let bitmap_key: i16 = 333;
        let bitmap_slot =
            Mapping::<i16, U256>::at_offset(orderbook_base, 3, Rc::clone(&address), bitmap_key);

        // Verify all fields compute different slots (they're independent)
        let bids_expected = mapping_slot(tick1.to_be_bytes(), orderbook_base + U256::from(1));
        let asks_expected = mapping_slot(tick2.to_be_bytes(), orderbook_base + U256::from(2));
        let bitmap_expected =
            mapping_slot(bitmap_key.to_be_bytes(), orderbook_base + U256::from(3));

        assert_eq!(bids_slot.slot(), bids_expected);
        assert_eq!(asks_slot.slot(), asks_expected);
        assert_eq!(bitmap_slot.slot(), bitmap_expected);

        // Verify they're all different
        assert_ne!(bids_slot.slot(), asks_slot.slot());
        assert_ne!(bids_slot.slot(), bitmap_slot.slot());
        assert_ne!(asks_slot.slot(), bitmap_slot.slot());
    }
}
