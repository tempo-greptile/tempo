---
id: TIP-1004
title: Permit for TIP-20
description: Addition of EIP-2612 permit functionality to TIP-20 tokens, enabling gasless approvals via off-chain signatures.
authors: Dan Robinson
status: Approved
related: TIP-1020
---

# TIP-1004: Permit for TIP-20

## Abstract

TIP-1004 adds EIP-2612 compatible `permit()` functionality to TIP-20 tokens, enabling gasless approvals via off-chain signatures. This allows users to approve token spending without submitting an on-chain transaction, with the approval being executed by any third party who submits the signed permit.

## Motivation

The standard ERC-20 approval flow requires users to submit a transaction to approve a spender before that spender can transfer tokens on their behalf. Among other things, this makes it difficult for a transaction to "sweep" tokens from multiple addresses that have never sent a transaction onchain. 

EIP-2612 introduced the `permit()` function which allows approvals to be granted via a signed message rather than an on-chain transaction. This enables:

- **Gasless approvals**: Users can sign a permit off-chain, and a relayer or the spender can submit the transaction
- **Single-transaction flows**: DApps can batch the permit with the subsequent action (e.g., approve + swap) in one transaction
- **Improved UX**: Users don't need to wait for or pay for a separate approval transaction

Since TIP-20 aims to be a superset of ERC-20 with additional functionality, adding EIP-2612 permit support ensures TIP-20 tokens work seamlessly with existing DeFi protocols and tooling that expect permit functionality.

This TIP adds the EIP-2612 `permit()`, as well as an updated implementation that takes in `bytes signature` instead of the `v, r, s` components of the ECDSA signature. This allows accounts with variable length signatures such as smart accounts, P256, and webauthn accounts to use permit.

### Alternatives

While Tempo transactions provide solutions for most of the common problems that are solved by account abstraction, they do not provide a way to transfer tokens from an address that has never sent a transaction onchain, which means it does not provide an easy way for a batched transaction to "sweep" tokens from many addresses.

While we plan to have Permit2 deployed on the chain, it, too, requires an initial transaction from the address being transferred from.

Adding a function for `transferWithAuthorization`, which we are also considering, would also solve this problem. But `permit` is somewhat more flexible, and we think these functions are not mutually exclusive.

---

# Specification

## New functions

The following functions are added to the TIP-20 interface:

```solidity
interface ITIP20Permit {
    /// @notice Approves `spender` to spend `value` tokens on behalf of `owner` via a signed permit
    /// @param owner The address granting the approval
    /// @param spender The address being approved to spend tokens
    /// @param value The amount of tokens to approve
    /// @param deadline Unix timestamp after which the permit is no longer valid
    /// @param v The recovery byte of the signature
    /// @param r Half of the ECDSA signature pair
    /// @param s Half of the ECDSA signature pair
    /// @dev The permit is valid only if:
    ///      - The current block timestamp is <= deadline
    ///      - The signature is valid and was signed by `owner`
    ///      - The nonce in the signature matches the current nonce for `owner`
    ///      Upon successful execution, increments the nonce for `owner` by 1.
    ///      Emits an {Approval} event.
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    /// @notice Approves `spender` to spend `value` tokens on behalf of `owner` via a signed permit
    /// @param owner The address granting the approval
    /// @param spender The address being approved to spend tokens
    /// @param value The amount of tokens to approve
    /// @param deadline Unix timestamp after which the permit is no longer valid
    /// @param signature The signature in bytes form
    /// @dev The permit is valid only if:
    ///      - The current block timestamp is <= deadline
    ///      - The signature is valid and was signed by `owner`
    ///      - The nonce in the signature matches the current nonce for `owner`
    ///      Upon successful execution, increments the nonce for `owner` by 1.
    ///      Emits an {Approval} event.
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        bytes calldata signature
    ) external;

    /// @notice Returns the current nonce for an address
    /// @param owner The address to query
    /// @return The current nonce, which must be included in any permit signature for this owner
    /// @dev The nonce starts at 0 and increments by 1 each time a permit is successfully used
    function nonces(address owner) external view returns (uint256);

    /// @notice Returns the EIP-712 domain separator for this token
    /// @return The domain separator bytes32 value
    /// @dev The domain separator is computed dynamically on each call as:
    ///      keccak256(abi.encode(
    ///          keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
    ///          keccak256(bytes(name())),
    ///          keccak256(bytes("1")),
    ///          block.chainid,
    ///          address(this)
    ///      ))
    ///      Dynamic computation ensures correct behavior after chain forks where chainId changes.
    function DOMAIN_SEPARATOR() external view returns (bytes32);
}
```

## EIP-712 Typed Data

The permit signature must conform to EIP-712 typed structured data signing. The domain and message types are defined as follows:

### Domain Separator

The domain separator is computed using the following parameters:

| Parameter | Value |
|-----------|-------|
| name | The token's `name()` |
| version | `"1"` |
| chainId | The chain ID where the token is deployed |
| verifyingContract | The TIP-20 token contract address |

```solidity
bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
    keccak256(bytes(name())),
    keccak256(bytes("1")),
    block.chainid,
    address(this)
));
```

### Permit Typehash

The permit message type is:

```solidity
bytes32 constant PERMIT_TYPEHASH = keccak256(
    "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"
);
```

### Signature Construction

To create a valid permit signature, the signer must sign the following EIP-712 digest:

```solidity
bytes32 structHash = keccak256(abi.encode(
    PERMIT_TYPEHASH,
    owner,
    spender,
    value,
    nonces[owner],
    deadline
));

bytes32 digest = keccak256(abi.encodePacked(
    "\x19\x01",
    DOMAIN_SEPARATOR,
    structHash
));
```

The signature must be produced by signing `digest` with the private key of `owner`.

For the `(v, r, s)` overload, pass the ECDSA signature components directly.

For the `bytes signature` overload, signatures must be encoded using the [TIP-1020 Signature Verification Precompile](./tip-1020.md) format:

| Type | Format | Length |
|------|--------|--------|
| secp256k1 | `r \|\| s \|\| v` | 65 bytes |
| P256 | `0x01 \|\| r \|\| s \|\| x \|\| y \|\| prehash` | 130 bytes |
| WebAuthn | `0x02 \|\| webauthn_data \|\| r \|\| s \|\| x \|\| y` | 129–2049 bytes |
| Keychain | `0x03 \|\| user_address \|\| inner_signature` | Variable |

See [Tempo Transaction signatures](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#signature-types) for encoding details.

## Behavior

### Nonces

Each address has an associated nonce that:
- Starts at `0` for all addresses
- Increments by `1` each time a permit is successfully executed for that address
- Must be included in the permit signature to prevent replay attacks

### Deadline

The `deadline` parameter is a Unix timestamp. The permit is only valid if `block.timestamp <= deadline`. This allows signers to limit the validity window of their permits.

### Pause State

The `permit()` function follows the same pause behavior as `approve()`. Since setting an allowance does not move tokens, `permit()` is allowed to execute even when the token is paused.

### TIP-403 Transfer Policy

The `permit()` function does not perform TIP-403 authorization checks, consistent with the behavior of `approve()`. Transfer policy checks are only enforced when tokens are actually transferred.

### Signature Validation

The implementation must:
1. Verify that `block.timestamp <= deadline`, otherwise revert with `PermitExpired`
2. Retrieve the current nonce for `owner` and use it to construct the `structHash` and `digest`
3. Increment `nonces[owner]`
4. Validate the signature using the [TIP-1020 Signature Verification Precompile](./tip-1020.md):
   - `(v, r, s)` signature case:
     - Encode the signature as `abi.encodePacked(r, s, v)` (65 bytes)
     - Call `ISignatureVerification(0x5165300000000000000000000000000000000000).verify(owner, digest, signature)`
     - If the call reverts, revert with `InvalidSignature`
   - `bytes signature` case:
     - Call `ISignatureVerification(0x5165300000000000000000000000000000000000).verify(owner, digest, signature)`
     - If the call reverts, revert with `InvalidSignature`
5. Set `allowance[owner][spender] = value`
6. Emit an `Approval(owner, spender, value)` event

> **Note**: The nonce is included in the signed digest, so nonce verification is implicit in signature validation — if the wrong nonce was signed, the TIP-1020 precompile will recover a different address and revert with `SignerMismatch`. The nonce is incremented before signature validation (steps 3-4) rather than after, ensuring reentrancy cannot replay the same signature.

### TIP-1020 Integration

TIP-1004 delegates signature verification to the [TIP-1020 Signature Verification Precompile](./tip-1020.md) at address `0x5165300000000000000000000000000000000000`. This provides native support for all Tempo signature types:

- **secp256k1**: Standard ECDSA signatures (EOAs)
- **P256**: WebAuthn-compatible passkey signatures
- **WebAuthn**: Full WebAuthn signatures with authenticator data
- **Keychain**: Delegated signatures via Account Keychain access keys

```solidity
interface ISignatureVerification {
    function verify(address signer, bytes32 hash, bytes calldata signature) external view returns (bool);
}

address constant SIGNATURE_VERIFICATION = 0x5165300000000000000000000000000000000000;

// Verify the permit signature
try ISignatureVerification(SIGNATURE_VERIFICATION).verify(owner, digest, signature) returns (bool) {
    // Signature is valid
} catch {
    revert InvalidSignature();
}
```

This enables P256 and WebAuthn accounts to use permits natively, without requiring smart contract wallet wrappers or EIP-1271.

## New errors

```solidity
/// @notice The permit signature has expired (block.timestamp > deadline)
error PermitExpired();

/// @notice The permit signature is invalid (wrong signer, malformed, or zero address recovered)
error InvalidSignature();
```

## New events

None. Successful permit execution emits the existing `Approval` event from TIP-20.

---

# Invariants

- `nonces(owner)` must only ever increase, never decrease
- `nonces(owner)` must increment by exactly 1 on each successful `permit()` call for that owner
- A permit signature can only be used once (enforced by nonce increment)
- A permit with a deadline in the past must always revert
- The recovered signer from a valid permit signature must exactly match the `owner` parameter
- After a successful `permit(owner, spender, value, ...)`, `allowance(owner, spender)` must equal `value`
- `DOMAIN_SEPARATOR()` must be computed dynamically and reflect the current `block.chainid`

## Test Cases

The test suite must cover:

1. **Happy path (secp256k1)**: Valid permit with ECDSA signature sets allowance correctly
2. **Expired permit**: Reverts with `PermitExpired` when `deadline < block.timestamp`
3. **Invalid signature**: Reverts with `InvalidSignature` for malformed signatures
4. **Wrong signer**: Reverts with `InvalidSignature` when signature is valid but signer ≠ owner
5. **Replay protection**: Second use of same signature reverts (nonce already incremented)
6. **Nonce tracking**: Verify nonce increments correctly after each permit
7. **Pause state**: Permit works when token is paused
8. **Domain separator**: Verify correct EIP-712 domain separator computation
9. **Domain separator chain ID**: Verify domain separator changes if chain ID changes
10. **Max allowance**: Permit with `type(uint256).max` value works correctly
11. **Allowance override**: Permit can override existing allowance (including to zero)
12. **Bytes signature (secp256k1)**: Valid `bytes signature` permit with 65-byte ECDSA signature sets allowance correctly
13. **Bytes signature (P256)**: Valid `bytes signature` permit with P256 signature sets allowance correctly
14. **Bytes signature (WebAuthn)**: Valid `bytes signature` permit with WebAuthn signature sets allowance correctly
15. **Bytes signature (Keychain)**: Valid `bytes signature` permit with Keychain signature sets allowance correctly
16. **Keychain unauthorized**: Reverts with `InvalidSignature` when keychain access key is not authorized
17. **Keychain expired**: Reverts with `InvalidSignature` when keychain access key has expired
18. **Bytes signature (invalid format)**: Reverts with `InvalidSignature` for unparseable signature bytes
