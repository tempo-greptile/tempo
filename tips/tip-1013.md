---
id: TIP-1013
title: Recovery Guardian Keys
description: Adds a valid_after timestamp to Access Keys enabling time-delayed recovery guardian patterns.
authors: Tanishk Goyal
status: Draft
related: TIP-1011, TIP-1012, TIP-1000, AccountKeychain, IAccountKeychain.sol
protocolVersion: TBD (requires hardfork)
---

# TIP-1013: Recovery Guardian Keys

## Abstract

This TIP extends Access Keys with a `validAfter` timestamp field, enabling time-delayed key activation. Combined with unlimited spending limits and unrestricted address scoping, this creates a **recovery guardian** pattern where a trusted third party can recover an account only after a configurable delay period—giving the original owner time to revoke the guardian if they still have access.

## Motivation

Users face a fundamental tradeoff between security and recoverability:

- **High security** (hardware wallets, multi-sig): Risk permanent loss if keys are lost
- **High recoverability** (custodial, social recovery): Trust third parties with immediate access

Current Access Key permissions (spending limits, expiry, destination scoping) don't solve this because they either:
1. Expire (useless for long-term recovery)
2. Have spending limits (can't recover full account)
3. Are immediately active (guardian could act maliciously)

### Recovery Guardian Pattern

A **recovery guardian** is a trusted party (friend, family member, institution, or hardware backup) that can take over an account, but only after a time delay.

#### Intended Flow

1. **Setup (off-chain)**: User creates and signs an Access Key authorization with:
   - No spending limits (unlimited access)
   - No destination restrictions (can interact with any contract)
   - `validAfter = now + 30 days` (or any delay period)
   
   The user sends this **signed authorization to the guardian off-chain** (e.g., via encrypted message, in-person handoff, or secure storage). The authorization is NOT submitted on-chain yet.

2. **Normal operation**: The guardian holds the signed authorization but does not submit it. No on-chain footprint exists.

3. **Recovery scenario**: If the user loses access:
   - Guardian submits the signed authorization on-chain, activating the key
   - The `validAfter` countdown begins from the original signature timestamp
   - After the delay period elapses, guardian can use the key to recover funds

4. **Attack prevention**: If the guardian submits the authorization maliciously while the user still has access:
   - User sees the `KeyAuthorized` event on-chain
   - User has until `validAfter` to revoke the guardian key
   - User can provision a new guardian with a fresh delay

This off-chain-first approach ensures:
- **No on-chain cost** until recovery is actually needed
- **Privacy**: Guardian relationship is not publicly visible until activated
- **Clear signal**: On-chain authorization serves as an explicit "recovery initiated" event

This mirrors social recovery patterns in smart contract wallets but at the protocol level.

### Use Cases

1. **Personal backup**: Provision a guardian key to a hardware wallet stored in a safe
2. **Family recovery**: Give a guardian key to a trusted family member
3. **Institutional recovery**: Enterprise accounts with IT department as guardian
4. **Dead man's switch**: Automatic inheritance if the owner becomes inactive
5. **Multi-guardian setup**: Multiple guardian keys with staggered `validAfter` times

### Threshold Recovery with Multisig Guardians

While this TIP defines single-key guardians, **threshold recovery** (M-of-N guardians) is achieved by setting the guardian key to a multisig account as defined in [TIP-1012](./tip-1012.md) ([PR #2298](https://github.com/tempoxyz/tempo/pull/2298)).

For example, to require 2-of-3 family members to recover an account:

1. Create a multisig account with 3 family members as owners and threshold of 2
2. Provision a guardian Access Key to the multisig address with `validAfter = 30 days`
3. If recovery is needed, 2 of the 3 family members sign a transaction from the multisig to recover the account

This composability allows TIP-1013 to remain simple (single timestamp field) while supporting arbitrarily complex guardian configurations through TIP-1012 multisig accounts.

### Account Locking via Scoped Guardians

Account locking (freezing funds during a suspected compromise) can be achieved by combining `validAfter` with destination address scoping from [TIP-1011](./tip-1011.md).

**Setup**: Provision a "lockdown guardian" Access Key with:
- Unlimited spending limits (can move all funds)
- `allowedDestinations = [vaultContract]` (can ONLY send to a recovery vault)
- `validAfter = 7 days` (short delay for emergency response)

**The vault contract** is a simple timelock that:
1. Accepts deposits from anyone
2. Only releases funds to the original depositor after a delay (e.g., 30 days)
3. Allows the original account owner to claim immediately with their primary key

**Lockdown flow**:
1. Guardian detects suspicious activity on the account
2. After `validAfter` passes, guardian moves all funds to the vault
3. Attacker cannot access the funds—they're locked in the vault
4. Original owner recovers their primary key and claims from the vault immediately

**Why this works**:
- Guardian cannot steal funds (destination-scoped to vault only)
- Guardian cannot interact with DeFi or drain value (no other destinations allowed)
- Attacker cannot front-run (vault only releases to original owner)
- Owner retains ultimate control (can claim from vault anytime)

This pattern provides "emergency freeze" capability without giving guardians custody of funds.

---

# Specification

## Extended Data Structures

### KeyAuthorization

**Current fields (from TIP-1011):**
```solidity
struct KeyAuthorization {
    TokenLimit[] spendingLimits;
    uint64 expiry;
    address[] allowedDestinations;
}
```

**Proposed addition:**
```solidity
struct KeyAuthorization {
    TokenLimit[] spendingLimits;
    uint64 expiry;              // Key becomes invalid after this time
    address[] allowedDestinations;
    uint64 validAfter;          // Absolute: key cannot be used before this timestamp
    uint64 activationDelay;     // Relative: seconds after authorization before key is usable
}
```

### Two-Field Activation Model

The key activation time is determined by **two independent constraints**:

| Field | Type | Purpose |
|-------|------|---------|
| `validAfter` | Absolute timestamp | "Key cannot be used before January 1st" |
| `activationDelay` | Duration (seconds) | "Key cannot be used until 30 days after authorization" |

**Activation time calculation** (computed on-chain when key is authorized):

```solidity
activatesAt = max(validAfter, block.timestamp + activationDelay)
```

A key is **usable** when: `activatesAt <= block.timestamp < expiry`

### Use Case Examples

| Scenario | `validAfter` | `activationDelay` | Effect |
|----------|--------------|-------------------|--------|
| Standard guardian | 0 | 30 days | Always 30-day warning after authorization |
| Scheduled handoff | Jan 1, 2027 | 0 | Usable on Jan 1, regardless of when authorized |
| Scheduled + warning | Jan 1, 2027 | 7 days | Usable on Jan 1 OR 7 days after auth, whichever is later |
| Immediate (legacy) | 0 | 0 | Usable immediately upon authorization |

### Why Two Fields?

**Problem with `validAfter` alone**: If the user signs `validAfter = now + 30 days` and the guardian waits 45 days to submit, the key is immediately active—no warning period.

**Problem with `activationDelay` alone**: Cannot express "this key should never be valid before a specific date" (e.g., inheritance scenarios).

**Solution**: Both fields together allow:
1. **Guaranteed warning period** via `activationDelay` (guardian cannot bypass by waiting)
2. **Scheduled activation** via `validAfter` (key cannot activate before a fixed date)

### Authorization vs. Activation

**Important distinction**:

- **Authorization**: A key MAY be authorized on-chain at any time. The precompile computes `activatesAt = max(validAfter, block.timestamp + activationDelay)` and stores it.
  
- **Activation**: A key can only be USED to sign transactions after `activatesAt` has passed. Until then, the key exists on-chain but is dormant.

This separation is critical for the recovery guardian flow:

1. Guardian submits the signed authorization → key is now **authorized** (on-chain)
2. `activatesAt` is computed and stored; user sees the authorization event
3. User has until `activatesAt` to revoke (guaranteed by `activationDelay`)
4. Only after `activatesAt` passes does the key become **active** (usable)

The `activationDelay` field **guarantees** a warning period regardless of when the guardian submits the authorization.

## Interface Changes

### IAccountKeychain.sol

```solidity
/// @notice Authorizes a key with activation constraints
/// @param key The public key to authorize
/// @param expiry Block timestamp when key expires (0 = no expiry)
/// @param validAfter Absolute timestamp before which key cannot be used (0 = no constraint)
/// @param activationDelay Seconds after authorization before key is usable (0 = no delay)
/// @param spendingLimits Token spending limits
/// @param allowedDestinations Addresses the key may call (empty = unrestricted)
/// @dev On authorization, activatesAt = max(validAfter, block.timestamp + activationDelay)
function authorizeKey(
    bytes calldata key,
    uint64 expiry,
    uint64 validAfter,
    uint64 activationDelay,
    TokenLimit[] calldata spendingLimits,
    address[] calldata allowedDestinations
) external;

/// @notice Returns the activation and expiry times for a key
/// @param key The public key to query
/// @return activatesAt Computed timestamp when key becomes usable
/// @return expiry Timestamp when key expires (0 = no expiry)
function getActivationWindow(bytes calldata key) external view returns (uint64 activatesAt, uint64 expiry);

/// @notice Extends the activation time for an existing key
/// @dev Can only increase activatesAt (push activation further into the future)
/// @param key The public key to update
/// @param newActivatesAt New timestamp when key becomes usable (must be > current activatesAt)
function extendActivation(bytes calldata key, uint64 newActivatesAt) external;
```

## Semantic Behavior

### Key Authorization Logic

When a key is authorized on-chain:

```
function authorizeKey(key, expiry, validAfter, activationDelay, ...):
    // Compute activation time
    activatesAt = max(validAfter, block.timestamp + activationDelay)
    
    // Validate constraints
    if expiry > 0 and activatesAt >= expiry:
        revert ActivationExceedsExpiry()
    
    // Store computed activatesAt (not the original fields)
    storage.activatesAt[key] = activatesAt
    storage.expiry[key] = expiry
    
    emit KeyAuthorized(key, activatesAt, expiry)
```

### Key Validation Logic

When a transaction is submitted with an Access Key:

```
function validateKeyTiming(key):
    activatesAt = storage.activatesAt[key]
    expiry = storage.expiry[key]
    
    // Check activation constraint
    if block.timestamp < activatesAt:
        revert KeyNotYetActive(activatesAt)
    
    // Check expiry constraint
    if expiry > 0 and block.timestamp >= expiry:
        revert KeyExpired(expiry)
    
    return true
```

### Guardian Key Update Rules

1. **Revocation**: The account owner can always revoke a guardian key entirely
2. **Activation extension**: The owner can call `extendActivation` to push `activatesAt` further into the future
3. **Activation reduction**: The owner CANNOT reduce `activatesAt`—this would defeat the security model
4. **Re-provisioning**: To reduce the delay, the owner must revoke and create a new key

```
function extendActivation(key, newActivatesAt):
    currentActivatesAt = storage.activatesAt[key]
    expiry = storage.expiry[key]
    
    if newActivatesAt <= currentActivatesAt:
        revert CannotReduceActivation()
    
    if expiry > 0 and newActivatesAt >= expiry:
        revert ActivationExceedsExpiry()
    
    storage.activatesAt[key] = newActivatesAt
    
    emit ActivationExtended(key, newActivatesAt)
```

### Interaction with Other Permissions

The `activatesAt` check is evaluated **first**, before any other permission checks:

1. `activatesAt` check (is the key active yet?)
2. `expiry` check (has the key expired?)
3. `allowedDestinations` check (can this key call this address?)
4. `spendingLimits` check (does this key have sufficient allowance?)

If `activatesAt` has not passed, the transaction reverts immediately without consuming spending limits or evaluating other constraints.

## Recovery Guardian Configuration

A typical recovery guardian key would be configured as:

```solidity
authorizeKey(
    guardianPublicKey,
    0,                          // No expiry
    0,                          // No absolute time constraint
    30 days,                    // 30-day warning period after authorization
    [],                         // No spending limits (unlimited)
    []                          // No destination restrictions
);
```

This creates a key that:
- Has a guaranteed 30-day warning period after authorization
- Has no expiry (valid indefinitely once active)
- Has no spending limits (full account access)
- Can interact with any contract

For inheritance/scheduled handoff scenarios:

```solidity
authorizeKey(
    heirPublicKey,
    0,                          // No expiry
    uint64(targetDate),         // Cannot activate before target date
    7 days,                     // Plus 7-day warning when authorized
    [],                         // Unlimited
    []                          // Unrestricted
);
```

This ensures the key cannot be used before `targetDate`, AND there's always at least a 7-day warning after authorization.

## Encoding

### RLP Encoding

The `KeyAuthorization` struct is extended with activation fields as trailing optional fields:

```
KeyAuthorization := RLP([
    spendingLimits: [TokenLimit, ...],
    expiry: uint64,
    allowedDestinations: [address, ...],  // From TIP-1011
    validAfter: uint64,                   // New: absolute timestamp constraint
    activationDelay: uint64               // New: relative delay in seconds
])
```

Using `#[rlp(trailing)]` semantics:
- Old encodings (without new fields) decode as `validAfter = 0, activationDelay = 0` (immediately valid)
- New encodings include both fields explicitly

## Precompile Storage

New storage slot for the computed activation time:

| Mapping | Type | Description |
|---------|------|-------------|
| `activates_at[key]` | `u64` | Computed timestamp when key becomes usable |

**Note**: We store the computed `activatesAt`, not the original `validAfter` and `activationDelay`. This simplifies validation and ensures the activation time is immutable once set (can only be extended).

Legacy keys (pre-fork) have `activatesAt = 0` (immediately valid).

## Gas Costs

| Operation | Gas Cost |
|-----------|----------|
| `authorizeKey` with activation fields | +2,000 (additional SSTORE for timestamp) |
| `extendActivation` | ~5,000 (single SSTORE update) |
| Activation check (per tx) | ~100 (timestamp comparison) |

---

# Backward Compatibility

This TIP requires a **hardfork** due to changes in transaction encoding and execution semantics.

## RLP Encoding Changes

`KeyAuthorization` gains two new trailing fields: `validAfter` and `activationDelay`. Using `#[rlp(trailing)]`:
- Pre-fork keys decode with `validAfter = 0, activationDelay = 0` (immediately valid)
- Post-fork keys may include either or both fields

## Hardfork-Gated Features

The following MUST be gated behind hardfork activation:

1. **RLP decoding**: Accept `validAfter` and `activationDelay` fields in `KeyAuthorization`
2. **Activation time computation**: Compute `activatesAt = max(validAfter, block.timestamp + activationDelay)`
3. **Activation enforcement**: Check `activatesAt` before allowing key usage
4. **New precompile storage**: Write to `activates_at[key]` slot
5. **New interface methods**: `getActivationWindow()`, `extendActivation()`

---

# Invariants

1. **Activation computation**: On authorization, `activatesAt` MUST be computed as `max(validAfter, block.timestamp + activationDelay)`

2. **Activation window**: A key MUST only be usable when `activatesAt <= block.timestamp < expiry` (with 0 meaning unbounded)

3. **Monotonic activation**: `activatesAt` can only be increased via `extendActivation()`, never decreased

4. **Window consistency**: When both `activatesAt` and `expiry` are non-zero, `activatesAt < expiry` MUST hold

5. **Backward compatibility**: Keys authorized without activation fields MUST behave as if `activatesAt = 0` (immediately valid)

6. **Check ordering**: The `activatesAt` check MUST be evaluated before spending limits or destination restrictions

7. **Revocation precedence**: Account owners MUST always be able to revoke guardian keys regardless of their activation status

## Test Cases

1. **Activation delay only**: Key with `validAfter=0, activationDelay=30 days` activates 30 days after authorization
2. **Valid after only**: Key with `validAfter=Jan1, activationDelay=0` activates on Jan 1 (or immediately if authorized after Jan 1)
3. **Both fields (delay dominates)**: `validAfter=Jan1, activationDelay=30 days`, authorized Dec 15 → activates Jan 14 (30 days from auth)
4. **Both fields (validAfter dominates)**: `validAfter=Jan1, activationDelay=7 days`, authorized Dec 15 → activates Jan 1 (validAfter is later)
5. **Stale authorization protection**: Key with `activationDelay=30 days` authorized 45 days after signing still requires 30-day wait
6. **Extend activation**: Verify `extendActivation` can only increase the timestamp
7. **Revocation**: Verify owner can revoke guardian key before it activates
8. **Zero values**: Verify `validAfter=0, activationDelay=0` means immediately valid
9. **Invalid window**: Verify authorization fails if computed `activatesAt >= expiry`
10. **Upgrade path**: Verify existing keys continue to work (interpreted as `activatesAt = 0`)
11. **Full recovery flow**: End-to-end test of off-chain signing, guardian submission, warning period, and recovery

## Security Considerations

### Attack Vectors

1. **Guardian collusion**: Mitigated by `activationDelay`—owner always has the configured warning period to react
2. **Stale authorization attack**: **MITIGATED** by the two-field model. Even if guardian waits until `validAfter` passes, `activationDelay` still applies from authorization time
3. **Key theft**: If the owner's main key is stolen, the guardian key provides a recovery path
4. **Guardian key theft**: Attacker must wait for `activatesAt`, giving owner time to revoke
5. **Time manipulation**: `block.timestamp` manipulation is bounded by consensus rules
6. **Off-chain authorization theft**: If someone steals the signed authorization, they can submit it—but `activationDelay` ensures a warning period

### Recommended Practices

1. **Always set activationDelay**: Use `activationDelay` (not just `validAfter`) to guarantee a warning period
2. **Multiple guardians**: Use 2-3 guardians with TIP-1012 multisig for threshold recovery
3. **Monitoring**: Set up alerts for `KeyAuthorized` events on your account
4. **Reasonable delays**: 7-30 days `activationDelay` recommended; too short reduces security, too long reduces recoverability
5. **Regular review**: Periodically verify guardian configurations are still appropriate

## Open Questions & Future Work

The following are known limitations that may be addressed in future TIPs:

1. **Guardian rotation cooldown**: An attacker who compromises the primary key can instantly revoke all guardians and add malicious ones. A cooldown on guardian changes would mitigate this but adds complexity.

2. **Heartbeat/dead man's switch**: No automatic guardian activation if the owner becomes inactive. Would require an external keeper or protocol-level check-in mechanism.

3. **Recovery cancellation**: Once a guardian submits an authorization, they cannot "cancel" if it was a mistake. The only recourse is for the owner to revoke.

4. **Minimum activation delay**: The protocol does not enforce a minimum `activationDelay`. Users could accidentally set very short delays. This is intentional (user choice) but risky.

## References

- [TIP-1011: Enhanced Access Key Permissions](./tip-1011.md)
- [TIP-1012: Multisig as Primary Signature Type](./tip-1012.md) ([PR #2298](https://github.com/tempoxyz/tempo/pull/2298))
- [AccountKeychain docs](https://docs.tempo.xyz/protocol/transactions/AccountKeychain)
- [Social Recovery Wallets](https://vitalik.eth.limo/general/2021/01/11/recovery.html) - Vitalik Buterin
