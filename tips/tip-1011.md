---
id: TIP-1011
title: Contract-Based Access Key Authorization
description: Extends Tempo access keys to support EVM contract verification, enabling multisig and social recovery use cases.
authors: Tempo AI @tempo-ai
status: Draft
related: TIP-1000, Porto External Keys
protocolVersion: T2
---

# TIP-1011: Contract-Based Access Key Authorization

## Abstract

This TIP extends Tempo's access key system to support EVM smart contract verification via a new `SignatureType::EvmContract` type. When an access key uses this type, signature validation is delegated to an on-chain contract implementing the `ITempoSigner` interface. Two reference implementations are provided as precompiles: `MultiSigSigner` for M-of-N threshold authorization and `RecoveryGuardian` for social recovery with timelocked execution.

## Motivation

Tempo's current access key system supports three signature types: Secp256k1, P256, and WebAuthn. While these cover individual key ownership, they cannot express more complex authorization policies:

1. **Multisig**: Organizations and high-value accounts need M-of-N threshold signing where multiple parties must approve transactions.

2. **Social Recovery**: Users need a way to recover account access if they lose their primary key, using trusted guardians with appropriate security delays.

3. **Extensibility**: Future authorization schemes (DAO governance, hardware enclaves, ZK proofs) should be possible without protocol changes.

**Alternatives Considered**:
- **Account abstraction via smart contract wallets**: Adds deployment costs and complexity; Tempo's native account model should support these use cases directly.
- **Protocol-level multisig**: Would require hard forks for each new authorization scheme.

The chosen approach—delegating to `ITempoSigner` contracts—provides flexibility while maintaining security through digest binding and account namespacing.

---

# Specification

## SignatureType Extension

A new signature type is added to the `KeyAuthorization` structure:

```
enum SignatureType {
    Secp256k1 = 0,
    P256 = 1,
    WebAuthn = 2,
    EvmContract = 3,  // NEW
}
```

For `EvmContract` keys:
- `publicKey` field contains the ABI-encoded contract address
- `contractSalt` field (new) contains a 32-byte salt for keyHash derivation

### KeyHash Derivation

The keyHash uniquely identifies a key configuration within a signer contract:

```
keyHash = keccak256(account || contractSalt)
```

This Porto-compatible derivation ensures:
- Each account has isolated configurations (no squatting)
- Multiple configurations per account are possible via different salts

## ITempoSigner Interface

Contracts acting as access key verifiers MUST implement:

```solidity
interface ITempoSigner {
    /// @notice ERC-1271 magic value (0x1626ba7e)
    function MAGIC_VALUE() external pure returns (bytes4);

    /// @notice Validate authorization for a contract-based access key
    /// @param account The Tempo account being authorized
    /// @param digest The bound digest to validate
    /// @param keyHash Identifies the key configuration
    /// @param signature Opaque authorization data
    /// @return magicValue 0x1626ba7e if valid, any other value otherwise
    function isValidSignatureWithKeyHash(
        address account,
        bytes32 digest,
        bytes32 keyHash,
        bytes calldata signature
    ) external view returns (bytes4 magicValue);
}
```

### Digest Binding

To prevent replay attacks, the AccountKeychain precompile binds the original transaction digest before calling the signer contract:

```
boundDigest = keccak256(
    "Tempo.EvmContract" ||
    chainId ||
    account ||
    originalDigest ||
    keyHash
)
```

The signer contract receives `boundDigest`, not the original digest. This ensures signatures are specific to:
- The Tempo chain (chainId)
- The authorizing account
- The specific key configuration (keyHash)
- The exact transaction being authorized

## Verification Flow

When validating a transaction with an `EvmContract` access key:

```
┌─────────────────┐     ┌──────────────────┐     ┌─────────────────┐
│  Transaction    │────▶│  AccountKeychain │────▶│  ITempoSigner   │
│  Validation     │     │  Precompile      │     │  Contract       │
└─────────────────┘     └──────────────────┘     └─────────────────┘
                               │                        │
                               │ 1. Compute keyHash     │
                               │ 2. Compute boundDigest │
                               │ 3. Call signer ────────┤
                               │                        │
                               │ 4. Check magicValue ◀──┤
                               │                        │
                               ▼                        ▼
                        Accept/Reject            Verify signatures
```

### Gas and Size Limits

To prevent DoS attacks:
- Maximum gas for signer contract call: **200,000 gas**
- Maximum `auth_data` (signature field) size: **8,192 bytes**

If the signer contract reverts or exceeds gas limits, verification fails.

---

## MultiSigSigner Precompile

**Address**: `0x5159000000000000000000000000000000000000`

Provides M-of-N threshold signature verification.

### Interface

```solidity
interface IMultiSigSigner is ITempoSigner {
    struct MultisigConfig {
        uint8 threshold;
        address[] owners;
    }

    /// @notice Initialize a multisig configuration
    /// @dev Can only be called once per (account, keyHash) pair
    /// @dev MUST be called by the account itself
    function initConfig(
        bytes32 keyHash,
        uint8 threshold,
        address[] calldata owners
    ) external;

    /// @notice Update threshold (requires current threshold signatures)
    function setThreshold(
        bytes32 keyHash,
        uint8 newThreshold,
        bytes calldata signatures
    ) external;

    /// @notice Add owner (requires current threshold signatures)
    function addOwner(
        bytes32 keyHash,
        address newOwner,
        bytes calldata signatures
    ) external;

    /// @notice Remove owner (requires current threshold signatures)
    /// @dev Threshold is reduced if it exceeds new owner count
    function removeOwner(
        bytes32 keyHash,
        address owner,
        bytes calldata signatures
    ) external;

    /// @notice Query configuration
    function getConfig(
        address account,
        bytes32 keyHash
    ) external view returns (MultisigConfig memory);
}
```

### Signature Encoding

The `signature` parameter for `isValidSignatureWithKeyHash` is ABI-encoded as:

```solidity
abi.encode(
    address[] signers,    // Addresses that signed (ascending order)
    bytes[] signatures    // Corresponding ECDSA signatures (65 bytes each)
)
```

**Validation Rules**:
1. `signers.length` MUST equal `signatures.length`
2. `signers.length` MUST be >= `threshold`
3. `signers` MUST be sorted in ascending order (prevents duplicate counting)
4. Each signer MUST be in the `owners` list
5. Each signature MUST be valid for the `boundDigest`

### Events

```solidity
event ConfigInitialized(address indexed account, bytes32 indexed keyHash, uint8 threshold, address[] owners);
event ThresholdUpdated(address indexed account, bytes32 indexed keyHash, uint8 newThreshold);
event OwnerAdded(address indexed account, bytes32 indexed keyHash, address indexed owner);
event OwnerRemoved(address indexed account, bytes32 indexed keyHash, address indexed owner);
```

### Errors

| Error | Condition |
|-------|-----------|
| `ConfigAlreadyExists` | `initConfig` called for existing (account, keyHash) |
| `ConfigNotFound` | Operation on non-existent config |
| `InvalidThreshold` | threshold = 0 or threshold > owners.length |
| `BelowThreshold` | Fewer valid signatures than required |
| `DuplicateOwner` | Same address appears twice in owners |
| `OwnerNotFound` | Removing non-existent owner |
| `InvalidSignerOrder` | Signers not in ascending order |
| `SignerNotOwner` | Signer address not in owners list |
| `TooFewOwners` | Resulting owner count would be 0 |

---

## RecoveryGuardian Precompile

**Address**: `0x8EC0000000000000000000000000000000000000`

Provides social recovery with guardian approval and timelock.

### Interface

```solidity
interface IRecoveryGuardian is ITempoSigner {
    struct RecoveryConfig {
        uint8 threshold;        // Guardian approvals required
        uint64 recoveryDelay;   // Seconds before execution
        address[] guardians;
    }

    struct RecoveryRequest {
        address newOwner;       // Proposed new owner
        uint64 executeAfter;    // Timestamp for execution
        uint8 approvalCount;    // Current approvals
    }

    /// @notice Initialize recovery configuration
    /// @dev MUST be called by the account itself
    /// @param recoveryDelay MUST be between 1 hour and 30 days
    function initConfig(
        bytes32 keyHash,
        uint8 threshold,
        uint64 recoveryDelay,
        address[] calldata guardians
    ) external;

    /// @notice Initiate recovery (called by guardian)
    function initiateRecovery(
        address account,
        bytes32 keyHash,
        address newOwner
    ) external;

    /// @notice Approve pending recovery (called by guardian)
    function approveRecovery(
        address account,
        bytes32 keyHash
    ) external;

    /// @notice Cancel recovery (called by account owner)
    function cancelRecovery(bytes32 keyHash) external;

    /// @notice Execute recovery after timelock
    /// @dev Anyone can call once threshold met and delay passed
    function executeRecovery(
        address account,
        bytes32 keyHash
    ) external returns (address newOwner);

    /// @notice Query configuration
    function getConfig(
        address account,
        bytes32 keyHash
    ) external view returns (RecoveryConfig memory);

    /// @notice Query pending request
    function getRecoveryRequest(
        address account,
        bytes32 keyHash
    ) external view returns (RecoveryRequest memory);

    /// @notice Check if guardian has approved
    function hasApproved(
        address account,
        bytes32 keyHash,
        address guardian
    ) external view returns (bool);
}
```

### Recovery Flow

```
┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐
│ Guardian │───▶│ Initiate │───▶│ Approve  │───▶│ Execute  │
│ starts   │    │ Recovery │    │ (others) │    │ (anyone) │
└──────────┘    └──────────┘    └──────────┘    └──────────┘
                     │               │               │
                     ▼               ▼               ▼
              Sets newOwner    Increments      After delay,
              Starts timer     approvalCount   sets new key
                     │               │               │
                     └───────────────┴───────────────┘
                                     │
                              Owner can cancel
                              at any point
```

### Timelock Constraints

- **Minimum delay**: 1 hour (3,600 seconds)
- **Maximum delay**: 30 days (2,592,000 seconds)

These bounds prevent both instant takeover (too short) and impractical recovery (too long).

### Events

```solidity
event RecoveryConfigured(address indexed account, bytes32 indexed keyHash, uint8 threshold, uint64 delay);
event RecoveryInitiated(address indexed account, bytes32 indexed keyHash, address indexed newOwner, uint64 executeAfter);
event RecoveryApproved(address indexed account, bytes32 indexed keyHash, address indexed guardian);
event RecoveryCancelled(address indexed account, bytes32 indexed keyHash);
event RecoveryExecuted(address indexed account, bytes32 indexed keyHash, address indexed newOwner);
```

### Errors

| Error | Condition |
|-------|-----------|
| `ConfigAlreadyExists` | Config already initialized |
| `ConfigNotFound` | No config for (account, keyHash) |
| `InvalidThreshold` | threshold = 0 or > guardians.length |
| `InvalidDelay` | Delay outside 1h–30d range |
| `NotGuardian` | Caller not in guardian list |
| `RecoveryAlreadyPending` | Initiate called with active request |
| `NoRecoveryPending` | Approve/execute with no active request |
| `AlreadyApproved` | Guardian approving twice |
| `ThresholdNotMet` | Execute before enough approvals |
| `RecoveryDelayNotPassed` | Execute before timelock expires |
| `InvalidNewOwner` | newOwner is zero address |
| `UnauthorizedCaller` | Cancel called by non-owner |

---

# Invariants

## Security Invariants

1. **Digest Uniqueness**: The `boundDigest` MUST be unique per (chain, account, keyHash, originalDigest) tuple. This prevents signature replay across chains, accounts, or configurations.

2. **Account Isolation**: A configuration for account A MUST NOT be usable to authorize transactions for account B, even if both use the same signer contract and salt.

3. **Threshold Enforcement**: MultiSigSigner MUST reject authorization if fewer than `threshold` valid signatures are provided.

4. **Timelock Integrity**: RecoveryGuardian MUST NOT allow execution before `executeAfter` timestamp, and `executeAfter` MUST be at least `recoveryDelay` seconds after initiation.

5. **Owner Cancellation**: The legitimate account owner MUST be able to cancel any pending recovery at any time before execution.

6. **Gas Exhaustion Protection**: Signer contract calls MUST be bounded to 200,000 gas to prevent DoS.

## Functional Invariants

7. **One-Time Initialization**: `initConfig` MUST revert if called twice for the same (account, keyHash).

8. **Self-Configuration**: Only the account itself MAY call `initConfig` (enforced via `msg.sender == account` or equivalent Tempo account check).

9. **Ascending Signer Order**: MultiSigSigner MUST reject signatures if signer addresses are not strictly ascending, preventing double-counting.

10. **Owner Count Minimum**: MultiSigSigner MUST NOT allow removing the last owner or setting threshold to 0.

## Test Cases

### MultiSigSigner

1. **Basic 2-of-3**: Initialize with 3 owners, threshold 2. Verify that 2 valid signatures succeed and 1 fails.
2. **Signer ordering**: Reject signatures if addresses not ascending.
3. **Non-owner signer**: Reject if any signer not in owners list.
4. **Threshold update**: Verify threshold change requires current threshold signatures.
5. **Add/remove owner**: Verify owner management requires authorization.
6. **Edge case**: 1-of-1 multisig (single owner).

### RecoveryGuardian

1. **Full recovery flow**: Initiate → approve (to threshold) → wait delay → execute.
2. **Owner cancellation**: Cancel pending recovery before execution.
3. **Early execution**: Reject execution before delay passes.
4. **Below threshold**: Reject execution with insufficient approvals.
5. **Double approval**: Reject same guardian approving twice.
6. **Non-guardian initiation**: Reject initiation by non-guardian.
7. **Delay bounds**: Reject delays outside 1h–30d range.

### Integration

1. **Access key registration**: Register EvmContract key, verify transactions validate correctly.
2. **Cross-account isolation**: Config for account A cannot authorize account B.
3. **Gas limit**: Signer contract exceeding 200k gas causes verification failure.
4. **Signature size limit**: Auth data exceeding 8KB rejected.
