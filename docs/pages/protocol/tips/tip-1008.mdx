# TIP-1008: Multi-Currency Fee AMM with Price Oracle

- **TIP ID**: TIP-1008
- **Authors/Owners**: Mallesh Pai
- **Status**: Draft
- **Related Specs/TIPs**: TIP-20, TIP Fee Manager
- **Protocol Version**: TBD

---

## Abstract

This TIP extends the existing feeAMM system to support fee payment in stablecoins denominated in currencies other than USD by introducing an off-chain price oracle service that pushes **USD per 1 unit of currency** rates for supported currencies on-chain. Users will be able to pay gas fees in tokens denominated in currencies such as EUR, GBP, JPY, etc. once enabled, while validators continue to receive USD-denominated tokens. The system maintains the existing 30bps fee structure and includes a staleness check that disables non-USD swaps when price data is not sufficiently fresh. 

---

## Motivation

### Problem Statement

The current feeAMM implementation only supports USD-denominated tokens. As a global protocol, we want to enable users to pay gas fees in stablecoins denominated in other currencies.

### Proposed Solution

Extend the feeAMM to accept tokens of any currency denomination by introducing a push-based oracle (potentially operated by Tempo) that publishes **USD per 1 unit of currency** rates on-chain. All non-USD currencies are converted to USD for validator payment, which removes cross-currency complexity, and swaps are guarded by a staleness threshold (300 seconds) so that non-USD swaps are disabled when prices are too old.



## Specification

### 1. Price Oracle Architecture

#### 1.1 Oracle Service

An off-chain service will push **USD per 1 unit of currency** rates to the chain. The oracle is initially operated by Tempo Protocol (with a future path to decentralization), targets a 1-5 minute update cadence under normal conditions, and starts with major currencies such as EUR, GBP, JPY, CNY, CHF, CAD, and AUD (the initial list of currencies is not yet determined). All rates are quoted against USD, which remains the base currency for validator payment.

The oracle is currency-code based: it publishes rates keyed by ISO 4217 currency codes (e.g., "EUR", "GBP", "JPY"). However, a currency must also be present in the **enabled currency codes list** (see Section 1.3) for fee swaps to be allowed. When a currency code is enabled in the feeAMM, it should also be accepted for fee payments elsewhere in the protocol (e.g., explicit transaction fee tokens).

#### 1.2 On-Chain Price Storage

Extend the TIP Fee Manager precompile to store and manage price data:

```solidity
/// @notice USD-per-currency exchange rate data
struct ExchangeRate {
    /// @dev Exchange rate scaled by RATE_SCALE (e.g., 1.0850 USD per EUR = 1085000)
    uint64 rate;

    /// @dev Block timestamp when this rate was published
    uint64 timestamp;
}

/// @dev Scaling factor for exchange rates (1000000 = 6 decimal places)
uint64 constant RATE_SCALE = 1000000;

/// @dev Maximum staleness for all currencies: 300 seconds (5 minutes)
uint64 constant MAX_STALENESS = 300;

/// @dev Oracle address authorized to push price updates (hardcoded at protocol level)
/// address constant ORACLE_ADDRESS = 0x...; // TBD
```

#### 1.3 Enabled Currency Codes

The protocol maintains a list of enabled currency codes. A currency must be in this list for non-USD fee swaps to be allowed. This list is defined at the protocol level and currently requires a hard fork to modify.

```solidity
/// @notice Check if a currency code is enabled for fee swaps
/// @param currency The currency code (e.g., "EUR", "GBP")
/// @return enabled Whether the currency is enabled
function isCurrencyEnabled(string calldata currency) external view returns (bool enabled);

/// @notice Get the list of all enabled currency codes
/// @return currencies Array of enabled currency code strings
function getEnabledCurrencies() external view returns (string[] memory currencies);
```

**Note**: USD is implicitly always enabled. A currency is only usable for swaps when both conditions are met: it is in the enabled list AND has a fresh oracle rate.

#### 1.4 Price Update Interface

```solidity
/// @notice Update USD-per-currency exchange rate
/// @dev Only callable by ORACLE_ADDRESS
/// @param currency The currency string (e.g., "EUR", "GBP", "JPY")
/// @param rate USD per 1 unit of currency, scaled by RATE_SCALE
/// @dev Example: USD per EUR = 1.0850 -> rate = 1085000
/// @dev Emits ExchangeRateUpdated event
function updateExchangeRate(
    string calldata currency,
    uint64 rate
) external;

/// @notice Batch update multiple USD-per-currency exchange rates
/// @dev Only callable by ORACLE_ADDRESS
/// @param currencies Array of currency strings
/// @param rates Array of USD-per-currency rates scaled by RATE_SCALE
/// @dev Arrays must be same length; emits ExchangeRateUpdated for each pair
function updateExchangeRatesBatch(
    string[] calldata currencies,
    uint64[] calldata rates
) external;

/// @notice Get the current USD-per-currency exchange rate
/// @param currency The currency string (e.g., "EUR", "GBP")
/// @return rate USD per 1 unit of currency, scaled by RATE_SCALE
/// @return timestamp Block timestamp of the rate
/// @return isStale Whether the rate exceeds MAX_STALENESS (300 seconds)
function getExchangeRate(
    string calldata currency
) external view returns (
    uint64 rate,
    uint64 timestamp,
    bool isStale
);
```

#### 1.5 Events

```solidity
/// @notice Emitted when an exchange rate is updated
/// @param currencyHash Keccak256 hash of the currency string (indexed for filtering)
/// @param currency The currency string (not indexed, for readability in logs)
/// @param rate The new USD-per-currency rate scaled by RATE_SCALE
/// @param timestamp Block timestamp of the update
event ExchangeRateUpdated(
    bytes32 indexed currencyHash,
    string currency,
    uint64 rate,
    uint64 timestamp
);
```

### 2. Multi-Currency Swap Mechanics

#### 2.1 Fee Swap Rate Calculation

When a user pays fees in a non-USD token, the swap amount is calculated using the oracle rate. The system verifies that the rate for the user's currency is sufficiently fresh, applies the existing 30bps fee multiplier (0.9970), converts the input to USD using the oracle, and outputs the USD amount for the validator.

**Formula**:
```
Given:
- userAmount: Amount of user token being swapped (e.g., 100 EUR)
- userCurrency: Currency of user token (e.g., "EUR")
- exchangeRate: USD per currency unit from oracle (e.g., USD per EUR = 1.0850, scaled to 1085000)
- M: Fee swap multiplier (9970, representing 0.9970)

Calculate:
usdAmount = (userAmount × M × exchangeRate) / (SCALE × RATE_SCALE)

Where:
- SCALE = 10000 (existing AMM scaling)
- RATE_SCALE = 1000000 (oracle rate scaling)

Example: 100 EUR at 1.0850 USD per EUR
usdAmount = (100,000,000 × 9970 × 1085000) / (10000 × 1000000)
         = 108,174,500 units
         = 108.17 USD
```

#### 2.2 Staleness Check Logic

Before executing any non-USD swap, the system checks that the oracle rate is no older than `MAX_STALENESS` (300 seconds):

```rust
const MAX_STALENESS: u64 = 300; // 5 minutes

fn is_price_fresh(
    currency: &str,
    last_update_timestamp: u64,
    current_timestamp: u64,
) -> bool {
    // USD is always "fresh" - no oracle needed
    if currency == "USD" {
        return true;
    }

    // Check if time elapsed exceeds threshold
    let age = current_timestamp.saturating_sub(last_update_timestamp);
    age <= MAX_STALENESS
}
```

**Behavior when price is stale**:
When a rate is older than 300 seconds, non-USD swaps are disabled and revert with `StaleExchangeRate`, while USD-only swaps continue to work. The user must wait for a fresh oracle update or use a USD-denominated token.

#### 2.3 Currency Pair Resolution (USD-Centric)

For any swap between `userToken` and `validatorToken`, the system reads currency strings from TIP-20 metadata and normalizes them to uppercase ASCII (for example, "eur" → "EUR") before lookups or storage. The validator currency must be `"USD"` or the swap reverts. If the user currency is also `"USD"`, the existing fixed-rate logic is used without the oracle. Otherwise, the system requires the oracle, fetches the USD-per-currency rate, enforces staleness, and computes the USD output using the 0.9970 multiplier.

This USD-centric design intentionally avoids cross-currency rate calculations, keeps the oracle to one rate per non-USD currency rather than N×N pairs, and simplifies staleness monitoring while matching the market reality that validators prefer USD-denominated tokens.

#### 2.4 Modified Swap Interface

The existing `execute_fee_swap()` function is extended internally:

```rust
// Internal function signature (not exposed in Solidity interface)
fn execute_fee_swap_with_oracle(
    user_token: Address,
    validator_token: Address,
    user_amount: U256,
    user_currency: String,
    validator_currency: String,
) -> Result<U256, Error> {
    // 1. Enforce USD-centric architecture
    if validator_currency != "USD" {
        return Err(Error::ValidatorMustBeUSD);
    }

    // 2. Check if user currency is USD (existing logic)
    if user_currency == "USD" {
        return execute_existing_fixed_rate_swap(user_amount);
    }

    // 3. Check if currency is enabled
    if !is_currency_enabled(&user_currency) {
        return Err(Error::CurrencyNotEnabled(user_currency));
    }

    // 4. Query oracle for USD-per-currency rate
    let rate = get_exchange_rate(&user_currency)?;

    // 5. Check price freshness (MAX_STALENESS = 300 seconds)
    let now = current_time();
    if !is_price_fresh(&user_currency, rate.timestamp, now) {
        let age = now.saturating_sub(rate.timestamp);
        return Err(Error::StaleExchangeRate(user_currency, age));
    }

    // 6. Calculate USD output with AMM fee (0.9970 multiplier)
    let usd_amount = calculate_usd_amount(user_amount, rate.rate)?;

    // 7. Execute swap
    execute_swap(user_token, validator_token, user_amount, usd_amount)
}
```

### 3. Rebalancing Swaps

Rebalancing swaps (liquidity provider arbitrage) follow the same USD-centric architecture. Only USD→Currency rebalancing is supported, using the existing rebalancing rate (N = 9985, meaning the swapper receives 1 unit of user token for every 0.9985 units of validator token they put in) and the current oracle rate with the same staleness checks as fee swaps.

**Formula**:
  ```
  Given: inputAmount USD, target currency, exchangeRate = USD per currency unit
  outputAmount = (inputAmount × SCALE × RATE_SCALE) / (N × exchangeRate)

  Where:
  - SCALE = 10000 (existing AMM scaling)
  - N = 9985 (rebalancing rate constant)
  - RATE_SCALE = 1000000 (oracle rate scaling)

  Example: 100 USD rebalanced to EUR at 1.0850 USD per EUR
  outputAmount = (100,000,000 × 10000 × 1000000) / (9985 × 1085000)
              = 92,304,268 units
              ≈ 92.30 EUR
  ```
This directionality is sufficient because validators accumulate USD and liquidity providers rebalance pools.

### 4. Access Control

- **Oracle updates**: Restricted to `ORACLE_ADDRESS` (hardcoded at protocol level); all other callers revert with `UnauthorizedOracle`.
- **Enabled currency list**: Hardcoded at the protocol level; modifications require a hard fork.
- **Staleness threshold**: Hardcoded at 300 seconds for all currencies; modifications require a hard fork. 


## Open Questions

Open questions include:
- how and when to decentralize the oracle,
- whether six decimal places of rate precision is sufficient for all currency pairs,
- which currencies to prioritize at launch,
- whether rebalancing economics need higher or per-currency fees,
- what emergency controls should be available during extreme volatility,
- whether non-USD validator preferences should be supported in a future redesign,
- whether to introduce an admin mechanism in the future to allow currency enablement and oracle configuration changes without hard forks, and/or something like an emergency pause mechanism 
- whether to have a maximum rate change per update
- whether to implement per-currency staleness thresholds calibrated to historical volatility (e.g., low-volatility pairs like EUR/USD could tolerate longer staleness windows, while higher-volatility currencies would require shorter windows)


---

## References

- [TIP-20 Token Standard](../tip20/spec.mdx)
- [TIP Fee Manager Specification](../fees/spec-fee-amm.mdx)
- [Tempo Protocol Documentation](https://docs.tempo.xyz)
